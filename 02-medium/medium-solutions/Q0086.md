## Q0086: [Partition List](https://leetcode.com/problems/partition-list/)

```
Difficulty Level: MEDIUM
```

```
Description:

Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes
greater than or equal to x.

You should preserve the original relative order of the nodes in each of the two partitions.
```

#### Python3:

```
class Solution:
    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:
        leftHead, rightHead = ListNode(), ListNode()
        left, right = leftHead, rightHead

        while head:
            if head.val < x:
                left.next = head
                left = left.next
            else:
                right.next = head
                right = right.next

            head = head.next

        left.next = rightHead.next
        right.next = None

        return leftHead.next
```

#### Java:

```
class Solution {
    public ListNode partition(ListNode head, int x) {
        ListNode leftHead = new ListNode();
        ListNode rightHead = new ListNode();
        ListNode left = leftHead;
        ListNode right = rightHead;

        while (head != null) {
            if (head.val < x) {
                left.next = head;
                left = left.next;
            } else {
                right.next = head;
                right = right.next;
            }

            head = head.next;
        }
            
        left.next = rightHead.next;
        right.next = null;

        return leftHead.next;
    }
}
```

#### JavaScript:

```
var partition = function(head, x) {
    var leftHead = new ListNode();
    var rightHead = new ListNode();
    var left = leftHead;
    var right = rightHead;

    while (head) {
        if (head.val < x) {
            left.next = head;
            left = left.next;
        } else {
            right.next = head;
            right = right.next;
        }

        head = head.next;
    }
            
    left.next = rightHead.next;
    right.next = null;

    return leftHead.next;
};
```

#### C++:

```
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        ListNode* leftHead = new ListNode();
        ListNode* rightHead = new ListNode();
        ListNode* left = leftHead;
        ListNode* right = rightHead;

        while (head) {
            if (head->val < x) {
                left->next = head;
                left = left->next;
            } else {
                right->next = head;
                right = right->next;
            }

            head = head->next;
        }
            
        left->next = rightHead->next;
        right->next = NULL;

        return leftHead->next;
    }
};
```

#### Scala:

```

```

#### Go:

```

```

#### C#:

```
public class Solution {
    public ListNode Partition(ListNode head, int x) {
        ListNode leftHead = new ListNode();
        ListNode rightHead = new ListNode();
        ListNode left = leftHead;
        ListNode right = rightHead;

        while (head != null) {
            if (head.val < x) {
                left.next = head;
                left = left.next;
            } else {
                right.next = head;
                right = right.next;
            }

            head = head.next;
        }
            
        left.next = rightHead.next;
        right.next = null;

        return leftHead.next;
    }
}
```

#### Swift:

```

```