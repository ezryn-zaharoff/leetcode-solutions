## Q0092: [Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/)

```
Difficulty Level: MEDIUM
```

```
Description:

Given the head of a singly linked list and two integers left and right where left <= right, reverse the nodes
of the list from position left to position right, and return the reversed list.
```

#### Python3:

```
class Solution:
    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:
        if not head or not head.next or left == right: return head

        dummy = ListNode(0, head)
        pre = dummy

        for _ in range(left - 1):
            pre = pre.next

        p, q = pre, pre.next
        curr = q

        for _ in range(right - left + 1):
            temp = curr.next
            curr.next = pre
            pre, curr = curr, temp

        p.next = pre
        q.next = curr

        return dummy.next
```

#### Java:

```
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        if (head == null || head.next == null || left == right) return head;

        ListNode dummy = new ListNode(0, head);
        ListNode pre = dummy;

        for (int i = 0; i < left - 1; i++) {
            pre = pre.next;
        }

        ListNode p = pre;
        ListNode q = pre.next;
        ListNode curr = q;

        for (int i = 0; i < right - left + 1; i++) {
            ListNode temp = curr.next;
            curr.next = pre;
            pre = curr;
            curr = temp;
        }

        p.next = pre;
        q.next = curr;

        return dummy.next;
    }
}
```

#### JavaScript:

```
var reverseBetween = function(head, left, right) {
    if (head == null || head.next == null || left == right) return head;

    let dummy = new ListNode(0, head);
    let pre = dummy;

    for (let i = 0; i < left - 1; i++) {
        pre = pre.next;
    }

    let p = pre;
    let q = pre.next;
    let curr = q;

    for (let i = 0; i < right - left + 1; i++) {
        let temp = curr.next;
        curr.next = pre;
        pre = curr;
        curr = temp;
    }

    p.next = pre;
    q.next = curr;

    return dummy.next;
};
```

#### C++:

```
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        if (!head || !head->next|| left == right) return head;

        ListNode* dummy = new ListNode(0, head);
        ListNode* pre = dummy;

        for (int i = 0; i < left - 1; i++) {
            pre = pre->next;
        }

        ListNode* p = pre;
        ListNode* q = pre->next;
        ListNode* curr = q;

        for (int i = 0; i < right - left + 1; i++) {
            ListNode* temp = curr->next;
            curr->next = pre;
            pre = curr;
            curr = temp;
        }

        p->next = pre;
        q->next = curr;

        return dummy->next;
    }
};
```

#### Scala:

```

```

#### Go:

```

```

#### C#:

```

```

#### Swift:

```

```