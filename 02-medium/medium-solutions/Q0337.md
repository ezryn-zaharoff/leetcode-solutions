## Q0337: [House Robber III](https://leetcode.com/problems/house-robber-iii/)

```
Difficulty Level: MEDIUM
```

```
Description:

The thief has found himself a new place for his thievery again. There is only one entrance to this area,
called root.

Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that
all houses in this place form a binary tree. It will automatically contact the police if two directly-linked
houses were broken into on the same night.

Given the root of the binary tree, return the maximum amount of money the thief can rob without alerting the
police.
```

#### Python3:

```
class Solution:
    def rob(self, root: Optional[TreeNode]) -> int:
        
        def dfs(node):
            if not node: return (0, 0)

            left = dfs(node.left)
            right = dfs(node.right)

            rob_curr = node.val + left[1] + right[1]
            not_rob_curr = max(left) + max(right)

            return (rob_curr, not_rob_curr)

        return max(dfs(root))
```

#### Java:

```
class Solution {
    public int rob(TreeNode root) {
        int[] ans = dfs(root);
        return Math.max(ans[0], ans[1]);
    }

    public int[] dfs(TreeNode node) {
        if (node == null) return new int[2];

        int[] left = dfs(node.left);
        int[] right = dfs(node.right);

        int ans[] = new int[2];
        ans[0] = node.val + left[1] + right[1];
        ans[1] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);

        return ans;
    }
}
```

#### JavaScript:

```

```

#### C++:

```

```

#### Scala:

```

```

#### Go:

```

```

#### C#:

```

```

#### Swift:

```

```

#### TypeScript:

```

```