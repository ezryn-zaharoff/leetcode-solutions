## Q0817: [Linked List Components](https://leetcode.com/problems/linked-list-components/)

```
Difficulty Level: MEDIUM
```

```
Description:

You are given the head of a linked list containing unique integer values and an integer array nums that is a
subset of the linked list values.

Return the number of connected components in nums where two values are connected if they appear consecutively
in the linked list.
```

#### Python3:

```
class Solution:
    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:
        numsSet = set(nums)
        curr = head
        count = 0

        while curr:
            if curr.val in numsSet:
                count += 1
                while curr is not None and curr.val in numsSet:
                    curr = curr.next
            else:
                curr = curr.next

        return count
```

#### Java:

```
class Solution {
    public int numComponents(ListNode head, int[] nums) {
        Set<Integer> numsSet = new HashSet<>();
        for (int num : nums) numsSet.add(num);

        ListNode curr = head;
        int count = 0;

        while (curr != null) {
            if (numsSet.contains(curr.val)) {
                count++;
                while (curr != null && numsSet.contains(curr.val))
                    curr = curr.next;
            } else {
                curr = curr.next;
            }
        }

        return count;
    }
}
```

#### JavaScript:

```
var numComponents = function(head, nums) {
    let numsSet = new Set(nums);
    let curr = head;
    let count = 0;

    while (curr != null) {
        if (numsSet.has(curr.val)) {
            count++;
            while (curr && numsSet.has(curr.val))
                curr = curr.next;
        } else {
            curr = curr.next;
        }
    }

    return count;
};
```

#### C++:

```

```

#### Scala:

```

```

#### Go:

```

```

#### C#:

```
public class Solution {
    public int NumComponents(ListNode head, int[] nums) {
        var curr = head;
        var count = 0;

        while (curr != null) {
            if (nums.Contains(curr.val)) {
                count++;
                while (curr != null && nums.Contains(curr.val))
                    curr = curr.next;
            }
            else {
                curr = curr.next;
            }
        }

        return count;
    }
}
```

#### Swift:

```

```