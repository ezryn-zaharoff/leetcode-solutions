## Q2415: [Reverse Odd Levels of Binary Tree](https://leetcode.com/problems/reverse-odd-levels-of-binary-tree/)

```
Difficulty Level: MEDIUM
```

```
Description:

Given the root of a perfect binary tree, reverse the node values at each odd level of the tree.

â€¢ For example, suppose the node values at level 3 are [2,1,3,4,7,11,29,18], then it should become
  [18,29,11,7,4,3,1,2].

Return the root of the reversed tree.

A binary tree is perfect if all parent nodes have two children and all leaves are on the same level.

The level of a node is the number of edges along the path between it and the root node.
```

#### Python3:

```
class Solution:
    def reverseOddLevels(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root: return None

        def dfs(node1, node2, level):
            if not node1 or not node2: return
            
            if level % 2 != 0:
                node1.val, node2.val = node2.val, node1.val

            dfs(node1.left, node2.right, level + 1)
            dfs(node2.left, node1.right, level + 1)

        dfs(root.left, root.right, 1)
        return root
```

#### Java:

```
class Solution {
    public TreeNode reverseOddLevels(TreeNode root) {
        if (root == null) return null;
            
        dfs(root.left, root.right, 1);
        return root;
    }

    public void dfs(TreeNode node1, TreeNode node2, int level) {
        if (node1 == null || node2 == null) return;
            
        if (level % 2 != 0) {
            int temp = node1.val;
            node1.val = node2.val;
            node2.val = temp;
        }

        dfs(node1.left, node2.right, level + 1);
        dfs(node2.left, node1.right, level + 1);
    }
}
```

#### JavaScript:

```

```

#### C++:

```

```

#### Scala:

```

```

#### Go:

```

```

#### C#:

```

```

#### Swift:

```

```

#### TypeScript:

```

```