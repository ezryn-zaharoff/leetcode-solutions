## Q3217: [Delete Nodes From Linked List Present in Array](https://leetcode.com/problems/delete-nodes-from-linked-list-present-in-array/)

```
Difficulty Level: MEDIUM
```

```
Description:

You are given an array of integers nums and the head of a linked list. Return the head of the modified linked
list after removing all nodes from the linked list that have a value that exists in nums.
```

#### Python3:

```
class Solution:
    def modifiedList(self, nums: List[int], head: Optional[ListNode]) -> Optional[ListNode]:
        if not head: return None

        nums = set(nums)
        dummy = ListNode(0, head)
        prev = dummy
        curr = head

        while curr != None:
            if curr.val in nums:
                prev.next = curr.next
            else:
                prev = curr

            curr = curr.next 

        return dummy.next
```

#### Java:

```
class Solution {
    public ListNode modifiedList(int[] nums, ListNode head) {
        if (head == null) return null;

        HashSet<Integer> numsSet = new HashSet<>();
        for (int num : nums) numsSet.add(num);

        ListNode dummy = new ListNode (0, head);
        ListNode prev = dummy;
        ListNode curr = head;

        while (curr != null) {
            if (numsSet.contains(curr.val)) {
                prev.next = curr.next;
            } else {
                prev = curr;
            }
                
            curr = curr.next;
        }

        return dummy.next;
    }
}
```

#### JavaScript:

```
var modifiedList = function(nums, head) {
    if (head == null) return null;
    
    let numsSet = new Set(nums);
    let dummy = new ListNode (0, head);
    let prev = dummy;
    let curr = head;

    while (curr) {
        if (numsSet.has(curr.val)) {
            prev.next = curr.next;
        } else {
            prev = curr;
        }
                
        curr = curr.next;
    }

    return dummy.next;
};
```

#### C++:

```
class Solution {
public:
    ListNode* modifiedList(vector<int>& nums, ListNode* head) {
        if (head == NULL) return NULL;

        set<int> numsSet;
        for (auto num : nums) numsSet.insert(num);

        ListNode* dummy = new ListNode (0, head);
        ListNode* prev = dummy;
        ListNode* curr = head;

        while (curr) {
            if (numsSet.find(curr->val) != numsSet.end()) {
                prev->next = curr->next;
            } else {
                prev = curr;
            }
                
            curr = curr->next;
        }

        return dummy->next;
    }
};
```

#### Scala:

```

```

#### Go:

```

```

#### C#:

```
public class Solution {
    public ListNode ModifiedList(int[] nums, ListNode head) {
        if (head == null) return null;

        var numsSet = new HashSet<int>(nums);
        ListNode dummy = new ListNode (0, head);
        ListNode prev = dummy;
        ListNode curr = head;

        while (curr != null) {
            if (numsSet.Contains(curr.val)) {
                prev.next = curr.next;
            } else {
                prev = curr;
            }
                
            curr = curr.next;
        }

        return dummy.next;
    }
}
```

#### Swift:

```

```