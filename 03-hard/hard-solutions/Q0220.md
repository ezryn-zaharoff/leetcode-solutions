## Q0220: [Contains Duplicate III](https://leetcode.com/problems/contains-duplicate-iii/)

```
Difficulty Level: HARD
```

```
Description:

You are given an integer array nums and two integers indexDiff and valueDiff.

Find a pair of indices (i, j) such that:

• i != j,
• abs(i - j) <= indexDiff.
• abs(nums[i] - nums[j]) <= valueDiff, and

Return true if such pair exists or false otherwise.
```

#### Python3:

```
class Solution:
    def containsNearbyAlmostDuplicate(self, nums: List[int], indexDiff: int, valueDiff: int) -> bool:
        buckets = {}
        width = valueDiff + 1

        for i, num in enumerate(nums):
            bucket = num // width
    
            if bucket in buckets:
                return True
            elif bucket - 1 in buckets and abs(num - buckets[bucket - 1]) <= valueDiff:
                return True
            elif bucket + 1 in buckets and abs(num - buckets[bucket + 1]) <= valueDiff:
                return True
            buckets[bucket] = num

            if i >= indexDiff:
                del buckets[nums[i - indexDiff] // width]

        return False
```

#### Java:

```
class Solution {
    public boolean containsNearbyAlmostDuplicate(int[] nums, int indexDiff, int valueDiff) {
        Map<Integer, Integer> buckets = new HashMap<>();
        int width = valueDiff + 1;
        int n = nums.length;

        for (int i = 0; i < n; i++) {
            int num = nums[i];
            int bucket = num < 0 ? (num + 1) / width - 1 : num / width;

            if (buckets.containsKey(bucket)) return true;
            if (buckets.containsKey(bucket - 1)
                    && Math.abs(num - buckets.get(bucket - 1)) <= valueDiff) return true;
            if (buckets.containsKey(bucket + 1)
                    && Math.abs(num - buckets.get(bucket + 1)) <= valueDiff) return true;
            buckets.put(bucket, num);

            if (i >= indexDiff) buckets.remove(nums[i - indexDiff] / width);
        }

        return false;
    }
}
```

#### JavaScript:

```
var containsNearbyAlmostDuplicate = function(nums, indexDiff, valueDiff) {
    var buckets = new Map()
    var width = valueDiff + 1
    var n = nums.length

    for (let i = 0; i < n; i++) {
        var num = nums[i]
        var bucket = Math.floor(num / width)

        if (buckets.has(bucket)) return true;
        if (buckets.has(bucket - 1) && Math.abs(num - buckets.get(bucket - 1)) < width) return true
        if (buckets.has(bucket + 1) && Math.abs(num - buckets.get(bucket + 1)) < width) return true
        buckets.set(bucket, num)

        if (i >= indexDiff) buckets.delete(Math.floor(nums[i - indexDiff] / width))
    }

    return false
};
```

#### C++:

```

```

#### Scala:

```

```

#### Go:

```

```

#### C#:

```

```

#### Swift:

```

```

#### TypeScript:

```
function containsNearbyAlmostDuplicate(nums: number[], indexDiff: number, valueDiff: number): boolean {
    var buckets = new Map()
    var width = valueDiff + 1
    var n = nums.length

    for (let i = 0; i < n; i++) {
        var num = nums[i]
        var bucket = Math.floor(num / width)

        if (buckets.has(bucket)) return true;
        if (buckets.has(bucket - 1) && Math.abs(num - buckets.get(bucket - 1)) < width) return true
        if (buckets.has(bucket + 1) && Math.abs(num - buckets.get(bucket + 1)) < width) return true
        buckets.set(bucket, num)

        if (i >= indexDiff) buckets.delete(Math.floor(nums[i - indexDiff] / width))
    }

    return false
};
```